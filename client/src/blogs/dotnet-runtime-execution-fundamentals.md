---
slug: dotnet-runtime-execution-fundamentals.md
title: How .NET actually works !!
date: 2025-12-30
tags: [".NET Core", ".NET Runtime", ".NET Fundamentals", "C#", "Execution Model"]
---


.NET(modern) is an open-source, cross-platform development platform, created by Microsoft for building high throughput applications using languages like C#, F#, supporting platforms like Windows, macOS, Linux. 

It provides a unified ecosystem for high-performance and scalable software development.

Before diving deep into .NET languages, libraries, and other features, we must understand the nuts & bolts of its internal working and in this article we are going to focus on the same.

### .NET Components -

.NET consists of following components which comes included in the package that we install from [Microsoft Dotnet](https://dotnet.microsoft.com/en-us/). These are - 
1. Common Language Runtime (CLR)
2. Framework Class Library (FCL)
3. Common Type Systems (CTS)
4. Common Language Specifications (CLS)

Here, we'll discuss the .NET Runtime and its execution model. It broadly includes - 
- CLR (Common Language Runtime)
- IL ( Intermediate Language)
- JIT Compilation
- Managed vs Unmanaged code
- Garbage Collection

Once we understand this runtime and execution model, everything else will just builds on it. So let's look behind the curtain and see how it all pans out in .NET world.

### Behind the scenes of executing any .NET/C# program

When we run C# program/application, it follow this sequence -
1. C# Compiler compiles the source code into intermediate language (IL) and packages it into an assembly (.dll/.exe file) along with metadata
2. During execution (runtime), the CLR loads the assembly (.dll/.exe file), verifies the IL for type safety (this is where CTS comes into picture).
3. The JIT (Just In Time) compiler, converts IL into machine-specific native code
4. The native code is executed by the CPU and CLR performs the memory management, [Garbage Collection](https://mockdotnet.dev/blogs/dotnet-garbage-collection), exception handling and security.


This is as simple as it gets for behind the scenes of any .NET applications. 

Let's dive deeper into some of its aspects.

### How CLR manages
CLR is Common Language Runtime. When we install .NET, it comes bundled with CLR. It is responsible for managing the execution of the application. It's the execution engine of .NET, it has following responsibilities - 
- Loading/Consuming IL
- Garbage Collection
- Memory Management
- Exception Handling
- JIT Compilation
- Execution of managed code
- Type Safety Checking


### Intermediate Language (IL)

Intermediate Language is a platform-independent instruction set generated by the C# Compiler. This is what makes .NET, actually cross-platform.

Platform is a combination of Operating System (Windows, macOS etc) and CPU architecture( x64, ARM64 etc). When we say IL is platform-independent, it means that it is not tied to any specific OS or CPU architecture. So it can also be exceuted (.NET CLR can manage this execution) other platforms in addition to where it was originally built.


This Intermediate Language is written in a .dll file, which we also call "Assembly". We can run this assembly on multiple platforms. Here's how - 
1. Create a .NET app on Windows
2. Compile it and build it.
3. Take the packaged .dll file and transfer it to macOS ("another platform").
4. Run this file on macOS but ensure .NET is installed in macOS. The just-in-time(JIT) compiler converts IL into macOS native code and exceutes it.

Now since every machine has its own architecture and runtime conditions, .NET CLR takes care of it on its own as per macOS ( or any other machine's specific architecture)

This works when the target machine has a compatible .NET runtime installed (framework-dependent deployment).

The intermediate language simplifies the execution and allows .NET to balance portability, performance and runtime optimizations.

The .dll file consists of this IL and its converted to machine native code, this code is tied to a specific platform and cannot be exceuted on other platforms. 

We do have some limitations to it, which restricts cross-platform execution -

- When we have platform-specific APIs
- We have different .NET versions installed

This is where the true essence of .NET being cross-platform lies! 

### Just-In-Time (JIT) Compiler 

As we have seen above, JIT compiler converts the IL into machine native code, this code is what is exceuted finally and we see the output. This conversion happens at runtime and not at build time. 

This is part of CLR, and it compiles IL method-by-method, that means when a method is called first time, then only actual conversion of IL code (for that specific method) to native code happens and then this native code is cached for future calls

For second call to that method, native code is picked from the cache and not converted at runtime.

JIT compiler is responsible for managing runtime conditions to convert IL into native code.

### Conclusion

We have covered the foundations of .NET execution Model. Its important to understand it before moving on to more complex topics like Memory Management, Garbage Collection etc.






